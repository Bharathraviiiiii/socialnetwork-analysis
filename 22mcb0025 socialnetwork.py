# -*- coding: utf-8 -*-
"""SNA_ASSIGN1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/137vme90YrLgIHX_18nP3aLOrPVIY8bOS
"""

# Import networkx and matplotlib.pyplot in the project file.
import matplotlib.pyplot as plt
import networkx as nx

#  empty undirected graph created
G = nx.Graph()

# Adding nodes to the graph
G.add_nodes_from([1, 2, 3, 4, 5, 6])

# each edge's weight by this rule
G.add_edge(1,2,weight=4)
G.add_edge(2,4,weight=6)
G.add_edge(3,6,weight=8)
G.add_edge(4,5,weight=10)
G.add_edge(5,3,weight=12)
G.add_edge(6,1,weight=14)

nx.draw(G, with_labels=True)
plt.show()

# Get the total number of nodes in the graph
num_nodes = G.number_of_nodes()
print("N0 of nodes:", num_nodes)

num_edges = G.number_of_edges()
print("No of edges:", num_edges)

max_degree = max(dict(G.degree()).items(), key=lambda x: x[1])[1]
nodes_max_degree = [n for n, deg in dict(G.degree()).items() if deg == max_degree]
print("Nodes with max degree:", nodes_max_degree)

# Get nodes with minimum degree
min_degree = min(dict(G.degree()).items(), key=lambda x: x[1])[1]
nodes_min_degree = [n for n, deg in dict(G.degree()).items() if deg == min_degree]
print("Nodes with minimum degree:", nodes_min_degree)

"""#Directed Graph"""

# Creating an empty directed graph
Gh = nx.DiGraph()

# Adding nodes to the graph
Gh.add_nodes_from([10, 20, 30, 40, 50, 60])

# Adding edges to the graph
Gh.add_edge(10, 20, weight=2)
Gh.add_edge(20, 30, weight=4)
Gh.add_edge(30, 40, weight=6)
Gh.add_edge(40, 50, weight=5)
Gh.add_edge(50, 60, weight=3)
Gh.add_edge(60, 10, weight =9)

nx.draw(Gh, with_labels=True)
plt.show()

# Getting the total number of nodes in the graph
num_nodes = Gh.number_of_nodes()
print("Number of nodes:", num_nodes)

# Getting the total number of edges in the graph
num_edges = Gh.number_of_edges()
print("Number of edges:", num_edges)

# Getting node with maximum out-degree
max_out_degree = max(dict(G.out_degree()).items(), key=lambda x: x[1])[1]
nodes_max_out_degree = [n for n, deg in dict(Gh.out_degree()).items() if deg == max_out_degree]
print("Node(s) with maximum out-degree:", nodes_max_out_degree)

# Getting node with minimum out-degree
min_out_degree = min(dict(Gh.out_degree()).items(), key=lambda x: x[1])[1]
nodes_min_out_degree = [n for n, deg in dict(Gh.out_degree()).items() if deg == min_out_degree]
print("Node(s) with minimum out-degree:", nodes_min_out_degree)

# Getting node with minimum in-degree
min_in_degree = min(dict(Gh.in_degree()).items(), key=lambda x: x[1])[1]
nodes_min_in_degree = [n for n, deg in dict(Gh.in_degree()).items() if deg == min_in_degree]
print("Node(s) with minimum in-degree:", nodes_min_in_degree)

# Getting node with maximum in-degree
max_in_degree = max(dict(Gh.in_degree()).items(), key=lambda x: x[1])[1]
nodes_max_in_degree = [n for n, deg in dict(Gh.in_degree()).items() if deg == max_in_degree]
print("Node(s) with maximum in-degree:", nodes_max_in_degree)

"""#Adjacency_matrix : Undirected_graph"""

import pandas as pd

edges = pd.read_csv('/content/edges.csv')
print(edges)

#list of all the vertices
vertices = list(set([v for e in edges for v in e]))

adj_matrix = [[0 for _ in range(len(vertices))] for _ in range(len(vertices))]

for e, w in edges.items():
    i = vertices.index(e[0])
    j = vertices.index(e[3])
    adj_matrix[i][j] = w
    adj_matrix[j][i] = w

for row in adj_matrix:
    print(row)

"""#Directed_graph"""

edges = {
    ('A', 'B'): 10,
    ('A', 'C'): 20,
    ('B', 'D'): 30,
    ('C', 'D'): 40
}

vertices = list(set([v for e in edges for v in e]))

# initialize an empty adjacency matrix
adj_matrix = [[0 for _ in range(len(vertices))] for _ in range(len(vertices))]

# fill in the adjacency matrix using the weights from the dictionary
for e, w in edges.items():
    i = vertices.index(e[3])
    j = vertices.index(e[9])
    adj_matrix[i][j] = w
    adj_matrix[j][i] = w

# print the adjacency matrix
for row in adj_matrix:
    print(row)

"""#Centrality measure """

import csv

G = nx.read_edgelist('/content/Centraliy_results.csv', delimiter=' ', nodetype=str)

degree_centrality = nx.degree_centrality(G)

# compute betweenness centrality
betweenness_centrality = nx.betweenness_centrality(G)

# compute closeness centrality
closeness_centrality = nx.closeness_centrality(G)

# compute PageRank centrality
pagerank_centrality = nx.pagerank(G)

# combine all centrality measures into one dictionary
centrality_measures = {
    'degree': degree_centrality,
    'betweenness': betweenness_centrality,
    'closeness': closeness_centrality,
    'pagerank': pagerank_centrality
}

# open a CSV file to write the results (replace filename with your own)
with open('centrality_results.csv', 'w', newline='') as csvfile:
    writer = csv.writer(csvfile)

"""#Centrality measures : Undirected and directed graph

"""

import networkx as nx
import pandas as pd

# create an example graph
G = nx.DiGraph()
G.add_edges_from([(1,2),(2,3),(3,4),(4,5),(5,6),(6,1)])

# calculate the centrality measures
deg = nx.degree_centrality(G)
bet = nx.betweenness_centrality(G)
clo = nx.closeness_centrality(G)
pr = nx.pagerank(G)

# create dataframes for the centrality measures
deg_df = pd.DataFrame.from_dict(deg, orient='index', columns=['degree'])
bet_df = pd.DataFrame.from_dict(bet, orient='index', columns=['between'])
clo_df = pd.DataFrame.from_dict(clo, orient='index', columns=['closeness'])
pr_df = pd.DataFrame.from_dict(pr, orient='index', columns=['pagerank'])

# combine the dataframes and sort by node name
centrality_df = pd.concat([deg_df, bet_df, clo_df, pr_df], axis=1)
centrality_df.index.name = 'node'
centrality_df = centrality_df.sort_index()

# output to csv files
centrality_df.to_csv('undirected_centrality.csv')
centrality_df.to_csv('directed_centrality.csv')

# calculate max and min scores for each centrality measure
deg_max, deg_min = centrality_df['degree'].max(), centrality_df['degree'].min()
bet_max, bet_min = centrality_df['between'].max(), centrality_df['between'].min()
clo_max, clo_min = centrality_df['closeness'].max(), centrality_df['closeness'].min()
pr_max, pr_min = centrality_df['pagerank'].max(), centrality_df['pagerank'].min()

print('Degree Centrality Max: {}, Min: {}'.format(deg_max, deg_min))
print('Betweenness Centrality Max: {}, Min: {}'.format(bet_max, bet_min))
print('Closeness Centrality Max: {}, Min: {}'.format(clo_max, clo_min))
print('Pagerank Max: {}, Min: {}'.format(pr_max, pr_min))