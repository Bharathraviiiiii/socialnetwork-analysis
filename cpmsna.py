# -*- coding: utf-8 -*-
"""cpmSNA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15uqxtaweGHExmi669Atm6428IaHFoOw6
"""

import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt

"""# LOADING DATSET"""

df=pd.read_csv('/content/InputFileEdges.csv')
df.head()

"""# CREATING GRAPH FROM THE DATASET"""

def undirected_graph(data):
    edges=[]
    for i in range(len(df)):
        edges.append((df.loc[i, 'Source'], df.loc[i, 'Destination'], df.loc[i, 'Weight']))
    G=nx.Graph()
    G.add_weighted_edges_from(edges)
    pos = nx.spring_layout(G)
    nx.draw_networkx_nodes(G, pos)
    nx.draw_networkx_edges(G, pos)
    nx.draw_networkx_edge_labels(G, pos, edge_labels={(u,v):d["weight"] for u,v,d in G.edges(data=True)})
    nx.draw_networkx_labels(G, pos)
    plt.axis('off')
    plt.show()
    nodes=list(G.nodes())
    print('Nodes of the above graph are:-\n',nodes)
    print('Total no of Nodes are:-',len(nodes))
    edges=list(G.edges())
    print('Edges of the above graph are:-\n',edges)
    print('Total no of Edges are:-\n',len(edges))
    print('Degree of nodes:-\n',G.degree( weight='weight'))
    degree=dict(G.degree( weight='weight'))
    degree_max=max(list(degree.values()))
    value = {i for i in degree if degree[i]==degree_max}
    print("max degree node:",value)
    degree_min=min(list(degree.values()))
    value = {i for i in degree if degree[i]==degree_min}
    print("min degree node:",value)
    return G

G=undirected_graph(df)

"""# FUNCTION FOR DETECTING CLIQUES, N-CLIQUES, N-CLANS, NCLUBS"""

def detect_cliques(graph):
    cliques = list(nx.find_cliques(graph))
    return cliques

def detect_n_cliques(graph, n):
    cliques = list(nx.find_cliques(graph))
    n_cliques = [clique for clique in cliques if len(clique) >= n]
    return n_cliques

def detect_n_clans(n_cliques):
    n_clans = []
    for clique1 in n_cliques:
        for clique2 in n_cliques:
            if clique1 != clique2 and set(clique1).issubset(set(clique2)):
                n_clans.append(list(set(clique1).union(set(clique2))))
    return n_clans

def detect_n_clubs(n_clans, n):
    n_clubs = [n_clan for n_clan in n_clans if len(n_clan) >= n]
    return n_clubs

"""### DETECTING CLIQUES"""

cliques = detect_cliques(G)
print("Cliques:")
for clique in cliques:
    print(clique)

"""### DETECTING N-CLIQUES"""

n = 3  # Define the minimum size of the n-cliques
n_cliques = detect_n_cliques(G, n)
print(f"\nn-cliques (n = {n}):")
for n_clique in n_cliques:
    print(n_clique)

"""### DETECTING N-CLANS"""

n_clans = detect_n_clans(n_cliques)
print(f"\nn-clans (n = {n}):")
for n_clan in n_clans:
    print(n_clan)

"""### DETECTING N-CLUBS"""

n_clubs = detect_n_clubs(n_clans, n)
print(f"\nn-clubs (n = {n}):")
for n_club in n_clubs:
    print(n_club)

"""## VISUALIZING CLIQUES IN THE GRAPH WITH DIFFERENT COLOURS"""

plt.figure()
pos = nx.spring_layout(G)
for i, clique in enumerate(cliques):
    nx.draw_networkx_nodes(G, pos, nodelist=clique, node_color=f"C{i}", label=f"Clique {i+1}")
nx.draw_networkx_edges(G, pos)
nx.draw_networkx_labels(G, pos)
plt.title("Cliques")
plt.show()

"""## DETECTING AND VISUALIZING COMMUNITIES WITH CLIQUES"""

def detect_communities(graph):
    cliques = list(nx.find_cliques(graph))
    communities = []
    for clique in cliques:
        found = False
        for community in communities:
            if any(node in community for node in clique):
                community.extend(clique)
                found = True
                break
        if not found:
            communities.append(clique)
    return communities

communities = detect_communities(G)

print("Communities:")
for i, community in enumerate(communities):
    print(f"Community {i+1}: {community}")

plt.figure()
pos = nx.spring_layout(G)
for i, community in enumerate(communities):
    nx.draw_networkx_nodes(G, pos, nodelist=community, node_color=f"C{i}", label=f"Community {i+1}")
nx.draw_networkx_edges(G, pos)
nx.draw_networkx_labels(G, pos)
plt.title("Communities")
plt.legend()
plt.show()

"""## FINDING COMMUNITIES WITH CPM COMMUNITY DETECTION ALGORITHM"""

import networkx as nx
import matplotlib.pyplot as plt
from itertools import combinations

def cpm_community_detection(G, k):
    node_to_clique = {}
    for node in G.nodes():
        node_neighbors = set(G.neighbors(node))
        for clique in node_to_clique.values():
            if len(clique.intersection(node_neighbors)) >= k-1:
                clique.add(node)
                break
        else:
            new_clique = set()
            new_clique.add(node)
            node_to_clique[node] = new_clique

    communities = []
    for clique in node_to_clique.values():
        communities.append(clique)

    return communities

# Detect communities using CPM with minimum clique size 3
communities = cpm_community_detection(G, 3)

# Generate colors for each community
colors = plt.cm.get_cmap('tab20', len(communities))

# Visualize the graph with communities
pos = nx.spring_layout(G)
for i, community in enumerate(communities):
    nx.draw_networkx_nodes(G, pos, node_color=colors(i), nodelist=list(community))
nx.draw_networkx_edges(G, pos, alpha=0.1)
plt.axis('off')
plt.show()

"""## FINDING COMMUNITIES WITH LOUVAIN COMMUNITY DETECTION ALGORITHM"""

#pip install python-louvain

import community
partition = community.best_partition(G)
print("Communities:")
for i, community in enumerate(partition):
    print(f"Community {i+1}: {community}")

pos = nx.spring_layout(G)
max_community = max(partition.values()) + 1
colors = plt.cm.get_cmap('tab10', max_community)

# Step 4: Visualize communities
plt.figure()
for community_id in set(partition.values()):
    nodes = [node for node, comm in partition.items() if comm == community_id]
    nx.draw_networkx_nodes(G, pos, nodelist=nodes, node_color=colors(community_id))

nx.draw_networkx_edges(G, pos)
nx.draw_networkx_labels(G, pos)
plt.title("Communities")
plt.show()

